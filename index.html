<!DOCTYPE html>
<html lang="en">
    <head>
        <style>
            body { margin: 0; }
            #matrix-rain { position: absolute; width: 100%; height: 100%; }
        </style>
    </head>
    <body>
        <canvas id="matrix-rain"></canvas>

        <script>
            const config = {
                fontSize: 14,
                fadeSpeed: 0.03,       // opacity lost per frame (lower = slower fade)
                frameDelay: 80,        // ms between frames (lower = faster animation)
                speedMin: 0.5,         // minimum drop speed (rows per frame)
                speedMax: 2.0,         // maximum drop speed (rows per frame)
                resetChance: 0.5,      // probability per frame of resetting after exiting bottom (higher = resets sooner)
                bgColor: '#000000',
                trailColor: 'hsl(160, 100%, 45%)',
                headColor: 'hsla(160, 100%, 85%, 1)',
                chars: 'アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン0123456789',
            };

            const canvas = document.getElementById('matrix-rain');
            const ctx = canvas.getContext('2d');
            let columns, drops, speeds, grid, prevHeads;

            function init() {
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                columns = Math.floor(canvas.width / config.fontSize);
                drops = Array.from({length: columns}, () => Math.random() * -canvas.height / config.fontSize);
                speeds = Array.from({length: columns}, () => config.speedMin + Math.random() * (config.speedMax - config.speedMin));
                grid = Array.from({length: columns}, () => ({})); // grid[col][row] = char
                prevHeads = new Array(columns).fill(-1);
                ctx.fillStyle = config.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            let lastTime = 0;

            function draw(time) {
                requestAnimationFrame(draw);
                if (time - lastTime < config.frameDelay) return;
                lastTime = time;

                ctx.globalAlpha = config.fadeSpeed;
                ctx.fillStyle = config.bgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
                ctx.font = config.fontSize + 'px monospace';

                for (let i = 0; i < columns; i++) {
                    const x = i * config.fontSize;
                    const head = Math.floor(drops[i]);

                    ctx.fillStyle = config.trailColor;
                    for (let r = Math.max(0, prevHeads[i]); r < head; r++) {
                        if (!grid[i][r]) grid[i][r] = config.chars[Math.floor(Math.random() * config.chars.length)];
                        ctx.fillText(grid[i][r], x, r * config.fontSize);
                    }

                    if (head >= 0) {
                        if (!grid[i][head]) grid[i][head] = config.chars[Math.floor(Math.random() * config.chars.length)];
                        ctx.fillStyle = config.headColor;
                        ctx.fillText(grid[i][head], x, head * config.fontSize);
                    }

                    prevHeads[i] = head;

                    if (drops[i] * config.fontSize > canvas.height && Math.random() < config.resetChance) {
                        drops[i] = 0;
                        prevHeads[i] = -1;
                    }
                    drops[i] += speeds[i];
                }
            }

            let lastWidth = canvas.offsetWidth;
            window.addEventListener('resize', () => {
                if (canvas.offsetWidth !== lastWidth) {
                    lastWidth = canvas.offsetWidth;
                    init();
                }
            });
            init();
            draw();
        </script>
    </body>
</html>
